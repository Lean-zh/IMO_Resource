"""
Functions for finding patterns of Problem 3 of IMO 2024.

Codes are generated by GPT-4o. See here for more details:

- https://shared-chats.lookeng.cn/IMO_2024_p3_gen_funcs.html
"""

def generate_sequence(initial_terms, num_terms):
    """
    根据给定的初始项和总项数，生成序列 (a1, a2, ... , an).

    参数:
    initial_terms (List[int]): 初始项列表，例如 [a1, a2, ..., aN]
    num_terms (int): 需要生成的总项数

    返回:
    List[int]: 生成的完整序列列表
    """
    if len(initial_terms) >= num_terms:
        return initial_terms[:num_terms]

    sequence = initial_terms[:]  # 用初始项列表初始化序列
    counts = {}  # 用来记录每个整数出现的次数
    
    # 初始化计数
    for num in initial_terms:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1

    # 生成序列
    for i in range(len(initial_terms), num_terms):
        last_term = sequence[-1]
        last_term_count = counts.get(last_term, 0)
        sequence.append(last_term_count)
        
        # 更新计数
        if last_term_count in counts:
            counts[last_term_count] += 1
        else:
            counts[last_term_count] = 1

    return sequence

def split_sequence(sequence):
    """
    将输入的完整序列拆分成奇数项和偶数项两个子序列。

    参数:
    sequence (List[int]): 完整的序列列表

    返回:
    Tuple[List[int], List[int]]: 奇数项序列列表和偶数项序列列表
    """
    odd_sequence = []
    even_sequence = []
    
    for i in range(len(sequence)):
        if i % 2 == 0:
            odd_sequence.append(sequence[i])
        else:
            even_sequence.append(sequence[i])

    return odd_sequence, even_sequence

def is_periodic(sequence, period, M):
    """
    检查给定序列是否在某个点之后以指定周期重复。

    参数:
    sequence (List[int]): 序列列表
    period (int): 检测周期
    M (int): 初始检查点

    返回:
    bool: 序列从 M 开始是否以 period 为周期重复
    """
    n = len(sequence)
    if M >= n:  # 如果 M 大于或等于序列长度，则无元素检查，返回 False
        return False

    for i in range(M, n - period):
        if sequence[i] != sequence[i + period]:
            return False
    
    return True

def find_period(sequence, min_repeat_len):
    """
    尝试找到序列中最短的周期及其起始位置和周期内容。

    参数:
    sequence (List[int]): 序列列表
    min_repeat_len (int): 重复周期的最小长度

    返回:
    Tuple[Optional[int], Optional[int], Optional[List[int]]]: 
    周期长度，起始位置，周期内容
    """
    n = len(sequence)
    for M in range(n - min_repeat_len):  # M 的有效范围
        for period in range(1, (n - M) // 2 + 1):
            if is_periodic(sequence, period, M):
                return (period, M, sequence[M:M + period])
    return None, None, None

def analyze_sequences(initial_terms, num_terms, min_repeat_len=None):
    """
    分析生成的序列，返回奇数项或偶数项的最终周期属性及其周期内容。

    参数:
    initial_terms (List[int]): 初始项列表
    num_terms (int): 需要生成的总项数
    min_repeat_len (int, optional): 重复周期的最小长度，默认为 max(3 * len(initial_terms), 10)

    返回:
    Tuple[str, Optional[int], Optional[List[int]]]: 
    序列属性，周期开始位置，周期内容
    """
    if min_repeat_len is None:
        min_repeat_len = max(3 * len(initial_terms), 5)

    # 生成完整序列
    sequence = generate_sequence(initial_terms, num_terms)
    
    # 拆分为奇数项和偶数项序列
    odd_sequence, even_sequence = split_sequence(sequence)
    
    # 检查奇数项序列的周期性
    period, start_position, period_content = find_period(odd_sequence, min_repeat_len)
    if period is not None:
        return "odd", start_position, period_content
    
    # 检查偶数项序列的周期性
    period, start_position, period_content = find_period(even_sequence, min_repeat_len)
    if period is not None:
        return "even", start_position, period_content

    return "none", None, None
